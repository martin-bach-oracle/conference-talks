<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
   xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:n0="http://www.oracle.com/xml/ns/dbchangelog-ext"
    xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.6.xsd">

   <changeSet
    id="r1-08"
    author="mcb"
    failOnError="true"
    runOnChange="false"
    runAlways="false">

        <n0:runOracleScript objectName="example-module" ownerName="EMILY" sourceType="STRING">
            <n0:source><![CDATA[
 
-- it is possible to add directives to the script
set define off
set verify off
 
create mle module demo_things_module language javascript as
/**
 * Based on https://diveintoapex.com/2024/03/05/simplify-apex-app-rest-apis-with-json-duality-views/
 * 
 * TODO
 * - create rollup/webpack plugin to conver this into SQLcl/Liquibase format (this has been
 *      done manually - ../liquibase/08_business_logic.xml)
 */

import validator from 'validator';

/**
 * Validate a price. Must not be negative, and can have 1 or 2 decimal
 * digits (optionally). Price must be in range [0.1;100000[
 * @param {string} price - the string to be validated
 * @returns {boolean} true if the validation passed, false otherwise
 */
export function validatePrice(price) {
    return validator.isCurrency(
        price,
        {
            allow_negatives: false,
            digits_after_decimal: [1,2]
        }
    ) && Number.parseFloat(price) <= 99999.99
}

/**
 * Validate that an available date is not more than a year old
 * @param {string} theDate a string to validate
 * @returns {boolean} whether or not theDate is > 1 year in the past
 */
export function validateAvailable(theDate) {

    const oneYearAgo = new Date(new Date().setFullYear(new Date().getFullYear() - 1));
    return validator.isAfter(
        theDate,
        oneYearAgo.toString()
    )
}

/**
 * Validate the quantity of things in stock. Must be integers (eg. no
 * fractional amounts allowed). The quantity cannot be negative, either
 * @param {string} quantity - the quantity of items in stock
 * @returns {boolean} true if the validation passed, false otherwise
 */
export function validateQuantity(quantity) {
    return validator.isInt(
        quantity, {
                gt:0
        }
    );
}

// validate_category and validate_warehouse have both not been implemented;
// this code relies on foreign key constraints instead

/**
 * change the price entered originally in the application to a more buyer
 * enticing number ending in .99 cent
 * @param {number} inputPrice the input price provided by the application
 * @returns {number} the more appealing price
 */
export function closest99Cent(inputPrice) {
    
    if (inputPrice < 1) {
        return 0.99;
    } 
    // biome-ignore lint: this is needed after all
    else if (inputPrice - Math.trunc(inputPrice) === 0.99) {
        return inputPrice;
    } 
    // biome-ignore lint: this is needed after all
    else {
        return Math.trunc(inputPrice) - 1 + .99;
    }
}

/**
 * consolidate multiple entries for stock in the same warehouse into one.
 * @param {number} thingID the thing in question
 */
export function consolidateThingWarehouses(thingID) {

    // check if there are multiple entries for stock in the same warehouse
    const result = session.execute(
        `select
            min(id) earliest_id,
            sum(nvl(quantity,0)) total_quantity,
            warehouse   
        from
            demo_thing_stock  
        where
            thing_id = :thingID
        group by
            warehouse  
        having
            count(*) > 1`,
        [ thingID ],
        { outFormat: oracledb.OUT_FORMAT_OBJECT }
    );

    // iterate over all the duplicate entries
    for (const row of result.rows) {

        // consolidate all stock in the first warehouse found in the table
        session.execute(
            `update 
                demo_thing_stock
            set
                quantity = :totalQuantity
            where
                id = :id`,
            [
                row.TOTAL_QUANTITY,
                row.EARLIEST_ID
            ]
        );

        // delete all other entries from warehouses
        session.execute(
            `delete
                demo_thing_stock
            where
                thing_id = :thingID and
                warehouse = :warehouse and
                id != :id`,
            [
                thingID,
                row.WAREHOUSE,
                row.EARLIEST_ID
            ]
        )
    }
}

/**
 * Default any missing warehouses for a thing with zero stock
 * @param {number} thingID the thing who's stock needs updating
 */
export function default_missing_warehouses(thingID) {
    session.execute(
        `merge 
            into demo_thing_stock tgt
            using (select id from demo_warehouse) src
            on (src.id = tgt.warehouse and tgt.thing_id = thingID)
         when
            not matched then
                insert (
                    thing_id,
                    warehouse,
                    quantity
                ) values (
                    thingID,
                    src.id,
                    0
                )`
    );
}
/

create mle env JAVASCRIPT_DEMO_ENV_THINGS imports (
    'demo'      module DEMO_THINGS_MODULE,
    'validator' module VALIDATOR_MODULE
)

]]></n0:source>
    </n0:runOracleScript>
  </changeSet>
</databaseChangeLog>